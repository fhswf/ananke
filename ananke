#!/usr/bin/env python3

import argparse
import logging
import os
import subprocess


LOG_FORMAT = '%(asctime)s %(levelname)s: %(message)s'
LOG_FILE = 'ananke.log'

IMG_DEF_DIR = 'images'
IMG_PREFIX = 'ananke-'

CONT_DEF_DIR = 'containers'
CONT_IGNORE_PREFIX = 'template'
CONFIG_FILE = 'config.py'

DEFAULT_VOLUMES = [
    ('dyn_home', '/var/lib/private'),
    ('home', '/home'),
    ('jupyterhub_config.d', '/opt/conda/envs/jhub/etc/jupyterhub/jupyterhub_config.d')
]

COLOR_RESET = '\x1b[0m'
COLOR_BOLD = '\x1b[1m'

BASE_PATH = os.path.abspath(os.path.dirname(__file__))

logger = logging.getLogger(__name__)


def shell(cmd):
    '''
    Run a shell command and return its output.

    Parameters
    ----------
    cmd : list[str]
        Command to execute. First item is command. Others are arguments.

    Returns
    -------
    list[str]
        List of lines returned on stdout.
    '''

    logger.info('Executing shell command "{}".'.format(' '.join(cmd)))
    result = subprocess.run(' '.join(cmd), capture_output=True, text=True, shell=True)
    logger.info('Shell command\'s output:\n' + result.stdout)

    return result.stdout.split('\n'), result.returncode


def get_img_defs():
    '''
    Return sorted list of available image definitions.

    Returns
    -------
    list[str]
        List of subdirectory names containing image definitions.
    '''

    img_defs = []
    path = f'{BASE_PATH}/{IMG_DEF_DIR}'
    logger.info(f'Looking for image definitions in {path}...')
    for name in os.listdir(path):
        if name.startswith(IMG_PREFIX) and os.path.isdir(f'{path}/{name}'):
            img_defs.append(name)

    return sorted(img_defs)


def get_imgs():
    '''
    Return list of available images.

    Returns
    -------
    list[(str, str, str)]
        List of (repo, name, tag) tuples for all images.
    '''

    imgs = []
    output, _ = shell('podman image ls'.split())
    for line in output[1:-1]:  # first line is header, last line is empty
        repo_and_name, tag, _ = line.split(maxsplit=2)
        repo, name = repo_and_name.rsplit('/', maxsplit=1)
        tag = tag if tag != '<none>' else ''
        if name.startswith(IMG_PREFIX):
            imgs.append((repo, name, tag))

    return imgs


def get_cont_defs():
    '''
    Return sorted list of available container definitions.

    Returns
    -------
    list[str]
        List of subdirectory names containing container definitions.
    '''

    cont_defs = []
    path = f'{BASE_PATH}/{CONT_DEF_DIR}'
    logger.info(f'Looking for container definitions in {path}...')
    for name in os.listdir(path):
        if not name.startswith(CONT_IGNORE_PREFIX) and os.path.isdir(f'{path}/{name}'):
            cont_defs.append(name)

    return sorted(cont_defs)


def get_conts():
    '''
    Return list of available containers.

    Returns
    -------
    list[(str, str)]
        List of (container_name, image_name) tuples for all containers.
    '''

    conts = []
    output, _ = shell('podman ps -a'.split())
    for line in output[1:-1]:  # first line is header, last line is empty
        _, cont_name = line.rsplit(maxsplit=1)
        _, img, _ = line.split(maxsplit=2)
        _, img_name = img.rsplit('/', maxsplit=1)
        if img_name.startswith(IMG_PREFIX):
            conts.append((cont_name, img))

    return conts


def choose(items, default):
    '''
    Let user choose one item from a list.

    Parameters
    ----------
    items : list[str]
        Items to choose from.
    default: int
        Index of default item.

    Returns
    -------
    int
        Index of chosen item.
    '''

    n = len(items)
    invalid = True
    while invalid:
        for i, item in enumerate(items):
            print(f'{i+1:2}) {item}')
        choice = input(f'Choose 1-{n} [{default+1}]: ')
        if choice == '':
            choice = default
            invalid = False
        else:
            try:
                choice = int(choice) - 1
                if choice >= 0 and choice < n:
                    invalid = False
            except ValueError:
                pass
        if invalid:
            print('ERROR: invalid input!')

    return choice


def subcmd_list(args):

    # list available image definitions
    img_defs = get_img_defs()
    print(f'{COLOR_BOLD}available image definitions:{COLOR_RESET}')
    for img_def in img_defs:
        print(f'  {img_def}')
    if len(img_defs) == 0:
        print('  none')

    # list available images
    imgs = get_imgs()
    print(f'{COLOR_BOLD}existing images{COLOR_RESET} ("podman image ls" for details):')
    for repo, name, tag in imgs:
        if tag != '':
            print(f'  {repo}/{name}:{tag}')
        else:
            print(f'  {repo}/{name} (no tag)')
    if len(imgs) == 0:
        print('  none')

    # list container definitions
    cont_defs = get_cont_defs()
    print(f'{COLOR_BOLD}available container definitions:{COLOR_RESET}')
    for cont_def in cont_defs:
        print(f'  {cont_def}')
    if len(cont_defs) == 0:
        print('  none')

    # list existing containers
    conts = get_conts()
    print(f'{COLOR_BOLD}existing containers{COLOR_RESET} ("podman ps -a" for details):')
    for cont_name, img_name in conts:
        print(f'  {cont_name} (using image {img_name})')
    if len(conts) == 0:
        print('  none')


def subcmd_build(args):

    # ask for image definition
    img_defs = get_img_defs()
    print('Which image definition shall be used?')
    choice = choose(img_defs, 0)
    img_def = img_defs[choice]

    # ask for image tag
    print(f'Image name will be "localhost/{img_def}:TAG".')
    tag = input('Choose a tag [latest]: ')
    if tag == '':
        tag = 'latest'

    # build image
    name = f'{img_def}:{tag}'
    print(f'Building image "{name}" from image definition "{img_def}" (this may take several minutes)...')
    _, code = shell(['podman', 'build', f'--tag={name}', f'{BASE_PATH}/{IMG_DEF_DIR}/{img_def}'])
    if code == 0:
        print('...done')
    else:
        print(f'An ERROR occured. See file {LOG_FILE} for details.')


def subcmd_create(args):

    # choose container definition
    cont_defs = get_cont_defs()
    print('Which container definition shall be used?')
    choice = choose(cont_defs, 0)
    cont_def = cont_defs[choice]

    # check wether container already exists
    conts = get_conts()
    if any([name == cont_def for name, _ in conts]):
        print('ERROR: Container already exists! Remove container before creating a new one.')
        return

    # load container config
    path = f'{BASE_PATH}/{CONT_DEF_DIR}/{cont_def}/{CONFIG_FILE}'
    try:
        with open(path) as f:
            config_code = f.read()
    except:
        print(f'ERROR: Container config file {path} could not be read! Not creating container.')
        return
    config = dict()
    exec(config_code)

    # check config
    required = ['image_name', 'port']
    if not all([r in config for r in required]):
        print(f'ERROR: One of keys {required} missing in container config file! Not creating container.')
    if 'podman_args' not in config:
        config['podman_args'] = []
    if 'volumes' not in config:
        config['volumes'] = []

    # default volumes
    config['volumes'].extend(DEFAULT_VOLUMES)

    # create directories for volumes and make paths absolute
    cont_path = f'{BASE_PATH}/{CONT_DEF_DIR}/{cont_def}'
    for i, (src, dest) in enumerate(config['volumes']):
        if not src.startswith('/'):
            src = f'{cont_path}/{src}'
            config['volumes'][i] = (src, dest)
        _, code = shell(['mkdir', '-p', src])
        if code != 0:
            print(f'ERROR: Creating directory {src} failed! Not creating container.')

    # create container
    cmd = ['podman', 'create', '--cap-add=SYS_ADMIN']
    cmd.append(f'--name="{cont_def}"')
    cmd.append(f'--publish={config["port"]}:8000')
    for src, dest in config['volumes']:
        cmd.append(f'--mount=type=bind,source="{src}",destination="{dest}"')
    for arg in config['podman_args']:
        cmd.append(arg)
    cmd.append(f'"{config["image_name"]}"')
    _, code = shell(cmd)
    if code != 0:
        print(f'ERROR: Container creation failed! See {LOG_FILE} for details.')
        return

    # create systemd unit
    shell(['podman', 'generate', 'systemd', '--restart-policy=always', '--files', f'--name {cont_def}'])
    shell('mkdir -p ~/.config/systemd/user'.split())
    _, code = shell(['mv', f'container-{cont_def}.service', f'~/.config/systemd/user/ananke-{cont_def}.service'])
    if code != 0:
        print(f'ERROR: Creating systemd service file failed! See {LOG_FILE} for details.')
        return
    shell('systemctl --user daemon-reload'.split())
    shell(['systemctl', '--user', 'enable', f'ananke-{cont_def}.service'])
    _, code = shell(['systemctl', '--user', 'start', f'ananke-{cont_def}.service'])
    if code != 0:
        print(f'ERROR: Starting systemd service failed! See {LOG_FILE} for details.')
        return

    # success
    print(f'Container {cont_def} now running. Systemd service name is "ananke-{cont_def}.service".')


def main():

    global logger

    # set up logging to log file
    path = f'{BASE_PATH}/{LOG_FILE}'
    try:
        handler = logging.FileHandler(path, mode='w')
        handler.setFormatter(logging.Formatter(LOG_FORMAT))
        logger.addHandler(handler)
    except Exception as e:
        print(f'ERROR: Creating log file failed ({e}). Aborting...')
    logger.setLevel(logging.INFO)
    logger.info('Logging initialized.')

    # intialize argument parser
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(
        title='subcommands',
        description='build, list ("ananke SUBCOMMAND -h" for details)'
    )

    # subparser for create command
    parser_create = subparsers.add_parser(
        'create',
        help='create and start a container'
    )
    parser_create.set_defaults(func=subcmd_create)

    # subparser for build command
    parser_build = subparsers.add_parser(
        'build',
        help='build an image'
    )
    parser_build.set_defaults(func=subcmd_build)

    # subparser for list command
    parser_list = subparsers.add_parser(
        'list',
        help='list images and containers'
    )
    parser_list.set_defaults(func=subcmd_list)

    # execute command
    args = parser.parse_args()
    if 'func' in args:
        args.func(args)
    else:
        parser.print_usage()


if __name__ == '__main__':
    main()
