#!/usr/bin/env python3

import argparse
import logging
import os
import subprocess


LOG_FORMAT = '%(asctime)s %(levelname)s: %(message)s'
LOG_FILE = 'ananke.log'

IMG_DEF_DIR = 'images'
IMG_PREFIX = 'ananke-'

CONT_DEF_DIR = 'containers'
CONT_IGNORE_PREFIX = 'template'
CONFIG_FILE = 'config.py'
CONT_PREFIX = 'ananke-'

DEFAULT_VOLUMES = [
    ('dyn_home', '/var/lib/private'),
    ('home', '/home'),
    ('jupyterhub_config.d', '/opt/conda/envs/jhub/etc/jupyterhub/jupyterhub_config.d')
]

COLOR_RESET = '\x1b[0m'
COLOR_BOLD = '\x1b[1m'
COLOR_RED = '\x1b[31m'

BASE_PATH = os.path.abspath(os.path.dirname(__file__))

logger = logging.getLogger(__name__)


def shell(cmd):
    '''
    Run a shell command and return its output.

    Parameters
    ----------
    cmd : list[str]
        Command to execute. First item is command. Others are arguments.

    Returns
    -------
    list[str]
        List of lines returned on stdout.
    '''

    logger.info(f'Executing shell command "{cmd}".')
    result = subprocess.run(cmd, capture_output=True, text=True, shell=True)
    logger.info('Shell command\'s output:\n' + result.stdout)

    return result.stdout.split('\n'), result.returncode


def get_img_defs():
    '''
    Return sorted list of available image definitions.

    Returns
    -------
    list[str]
        List of subdirectory names containing image definitions.
    '''

    img_defs = []
    path = f'{BASE_PATH}/{IMG_DEF_DIR}'
    logger.info(f'Looking for image definitions in {path}...')
    for name in os.listdir(path):
        if name.startswith(IMG_PREFIX) and os.path.isdir(f'{path}/{name}'):
            img_defs.append(name)

    return sorted(img_defs)


def get_imgs():
    '''
    Return list of available images.

    Returns
    -------
    list[(str, str, str)]
        List of (repo, name, tag) tuples for all images.
    '''

    imgs = []
    output, _ = shell('podman image ls')
    for line in output[1:-1]:  # first line is header, last line is empty
        repo_and_name, tag, _ = line.split(maxsplit=2)
        repo, name = repo_and_name.rsplit('/', maxsplit=1)
        tag = tag if tag != '<none>' else ''
        if name.startswith(IMG_PREFIX):
            imgs.append((repo, name, tag))

    return imgs


def get_cont_defs():
    '''
    Return sorted list of available container definitions.

    Returns
    -------
    list[str]
        List of subdirectory names containing container definitions.
    '''

    cont_defs = []
    path = f'{BASE_PATH}/{CONT_DEF_DIR}'
    logger.info(f'Looking for container definitions in {path}...')
    for name in os.listdir(path):
        if not name.startswith(CONT_IGNORE_PREFIX) and os.path.isdir(f'{path}/{name}'):
            cont_defs.append(name)

    return sorted(cont_defs)


def get_conts():
    '''
    Return list of available containers.

    Returns
    -------
    list[(str, str)]
        List of (container_name, image_name) tuples for all containers.
    '''

    conts = []
    output, _ = shell('podman ps -a')
    for line in output[1:-1]:  # first line is header, last line is empty
        _, cont_name = line.rsplit(maxsplit=1)
        _, img, _ = line.split(maxsplit=2)
        if cont_name.startswith(CONT_PREFIX):
            conts.append((cont_name, img))

    return conts


def choose(items, default):
    '''
    Let user choose one item from a list.

    Parameters
    ----------
    items : list[str]
        Items to choose from.
    default : int
        Index of default item.

    Returns
    -------
    int
        Index of chosen item.
    '''

    n = len(items)
    invalid = True
    while invalid:
        for i, item in enumerate(items):
            print(f'{i+1:2}) {item}')
        choice = input(f'Choose 1-{n} [{default+1}]: ')
        if choice == '':
            choice = default
            invalid = False
        else:
            try:
                choice = int(choice) - 1
                if choice >= 0 and choice < n:
                    invalid = False
            except ValueError:
                pass
        if invalid:
            print('ERROR: invalid input!')

    return choice


def ask_yes(default):
    '''
    Let user choose between yes and no.

    Parameters
    ----------
    default : bool
        Default answer (False == no).

    Returns
    -------
    bool
        Answer (False == no).
    '''

    invalid = True
    while invalid:
        choice = input(f'y/yes or n/no [{"y" if default else "n"}]: ')
        choice = choice.lower()
        if choice == '':
            choice = default
            invalid = False
        elif choice in ['y', 'yes']:
            choice = True
            invalid = False
        elif choice in ['n', 'no']:
            choice = False
            invalid = False
        if invalid:
            print('ERROR: invalid input!')

    return choice


def load_config(path):
    '''
    Read container config file.

    Parameters
    ----------
    path : str
        Path of config file.

    Returns
    -------
    dict
        Content of config file (None if error).
    '''

    try:
        with open(path) as f:
            config_code = f.read()
    except:
        print(f'ERROR: Container config file {path} could not be read!')
        return None
    config = dict()
    exec(config_code)

    return config


def subcmd_list(args):

    # list available image definitions
    img_defs = get_img_defs()
    print(f'{COLOR_BOLD}available image definitions:{COLOR_RESET}')
    for img_def in img_defs:
        print(f'  {img_def}')
    if len(img_defs) == 0:
        print('  none')

    # list available images
    imgs = get_imgs()
    print(f'{COLOR_BOLD}existing images{COLOR_RESET} ("podman image ls" for details):')
    for repo, name, tag in imgs:
        if tag != '':
            print(f'  {repo}/{name}:{tag}')
        else:
            print(f'  {repo}/{name} (no tag)')
    if len(imgs) == 0:
        print('  none')

    # list container definitions
    cont_defs = get_cont_defs()
    print(f'{COLOR_BOLD}available container definitions:{COLOR_RESET}')
    for cont_def in cont_defs:
        print(f'  {cont_def}')
    if len(cont_defs) == 0:
        print('  none')

    # list existing containers
    conts = get_conts()
    print(f'{COLOR_BOLD}existing containers{COLOR_RESET} ("podman ps -a" for details):')
    for cont_name, img_name in conts:
        print(f'  {cont_name} (using image {img_name})')
    if len(conts) == 0:
        print('  none')


def subcmd_build(args):

    # ask for image definition
    img_defs = get_img_defs()
    print('Which image definition shall be used?')
    choice = choose(img_defs, 0)
    img_def = img_defs[choice]

    # ask for image tag
    print(f'Image name will be "localhost/{img_def}:TAG".')
    tag = input('Choose a tag [latest]: ')
    if tag == '':
        tag = 'latest'

    # build image
    name = f'{img_def}:{tag}'
    print(f'Building image "{name}" from image definition "{img_def}" (this may take several minutes)...')
    _, code = shell(f'podman build --tag={name} "{BASE_PATH}/{IMG_DEF_DIR}/{img_def}"')
    if code == 0:
        print('...done')
    else:
        print(f'An ERROR occured. See file {LOG_FILE} for details.')


def subcmd_create(args):

    # choose container definition
    cont_defs = get_cont_defs()
    print('Which container definition shall be used?')
    choice = choose(cont_defs, 0)
    cont_def = cont_defs[choice]
    cont_name = f'{CONT_PREFIX}{cont_def}'

    # check wether container already exists
    conts = get_conts()
    if any([name == cont_name for name, _ in conts]):
        print('ERROR: Container already exists! Remove container before creating a new one.')
        return

    # load container config
    path = f'{BASE_PATH}/{CONT_DEF_DIR}/{cont_def}/{CONFIG_FILE}'
    config = load_config(path)
    if not config:
        print('Not creating container.')
        return

    # check config
    required = ['image_name', 'port']
    if not all([r in config for r in required]):
        print(f'ERROR: One of keys {required} missing in container config file! Not creating container.')
    if 'podman_args' not in config:
        config['podman_args'] = []
    if 'volumes' not in config:
        config['volumes'] = []

    # default volumes
    config['volumes'].extend(DEFAULT_VOLUMES)

    # create directories for volumes and make paths absolute
    cont_path = f'{BASE_PATH}/{CONT_DEF_DIR}/{cont_def}'
    for i, (src, dest) in enumerate(config['volumes']):
        if not src.startswith('/'):
            src = f'{cont_path}/{src}'
            config['volumes'][i] = (src, dest)
        _, code = shell(f'mkdir -p "{src}"')
        if code != 0:
            print(f'ERROR: Creating directory {src} failed! Not creating container.')

    # create container
    cmd = 'podman create --cap-add=SYS_ADMIN'
    cmd += f' --name="{cont_name}"'
    cmd += f' --publish={config["port"]}:8000'
    for src, dest in config['volumes']:
        cmd += f' --mount=type=bind,source="{src}",destination="{dest}"'
    for arg in config['podman_args']:
        cmd += f' {arg}'
    cmd += f' "{config["image_name"]}"'
    _, code = shell(cmd)
    if code != 0:
        print(f'ERROR: Container creation failed! See {LOG_FILE} for details.')
        return

    # create systemd unit
    shell(f'podman generate systemd --restart-policy=always --files --name "{cont_name}"')
    shell('mkdir -p ~/.config/systemd/user')
    _, code = shell(f'mv "container-{cont_name}.service" ~/.config/systemd/user/"{cont_name}.service"')
    if code != 0:
        print(f'ERROR: Creating systemd service file failed! See {LOG_FILE} for details.')
        return
    shell('systemctl --user daemon-reload')
    shell(f'systemctl --user enable "{cont_name}.service"')
    _, code = shell(f'systemctl --user start "{cont_name}.service"')
    if code != 0:
        print(f'ERROR: Starting systemd service failed! See {LOG_FILE} for details.')
        return

    # create script for starting root shell
    path = f'{BASE_PATH}/{cont_name}.sh'
    try:
        with open(path, 'w') as f:
            f.write(f'#!/bin/bash\n\npodman exec -it "{cont_name}" /bin/bash\n')
        shell(f'chmod u+x {path}')
        print(f'Run {cont_name}.sh to get a root shell inside the container.')
    except Exception as e:
        print(f'Could not create shell script {path}. See {LOG_FILE} for details.')
        logger.error(f'Could not create shell script ({str(e)})')

    # success
    print(f'Container {cont_def} now running. Systemd service name is "{cont_name}.service".')


def subcmd_remove(args):

    # choose container
    cont_names = [cont_name for cont_name, img_name in get_conts()]
    if len(cont_names) == 0:
        print('There are no Ananke containers!')
        return
    print('Which container shall be removed?')
    choice = choose(cont_names, 0)
    cont_name = cont_names[choice]

    # load container config
    path = f'{BASE_PATH}/{CONT_DEF_DIR}/{cont_name[len(CONT_PREFIX):]}/{CONFIG_FILE}'
    config = load_config(path)
    if not config:
        if ask_yes(f'Could not read container config file {path}. Do you want to remove the container nevertheless?'):
            config = dict()
        else:
            print('Not removing container.')
            return

    # add default volumes
    if 'volumes' not in config:
        config['volumes'] = []
    config['volumes'].extend(DEFAULT_VOLUMES)

    # ask user for transfer of volume ownership
    print(f'{COLOR_BOLD}You may now transfer ownership of files in container volumes to you. This simplifies modifying and deleting files created during container runtime, but may cause troubles if you plan to reuse volumes in a new container. Changes won\'t be applied immediately, but only after confirming container removal.{COLOR_RESET}')
    transfer_paths = []
    for src, dest in config['volumes']:
        print(f'Transfer ownership of volume\n  "{src}" (host) > "{dest}" (container)\nto you?')
        if ask_yes(False):
            transfer_paths.append(dest)

    # ask user for container restart
    if len(transfer_paths) > 0:
        output, _ = shell('podman inspect --format "{{.State.Running}}"' + f' "{cont_name}"')
        cont_running = (len(output) > 0 and output[0].startswith('true'))
        if not cont_running:
            print('{COLOR_BOLD}You chose to transfer ownership of some volumes, but the container isn\'t running at the moment. The container will be started to transfer ownership. In rare situations this may cause security issues due to opening the container\'s port. Proceed?{COLOR_RESET}')
            if not ask_yes(True):
                print('Aborting. Not removing container.')
                return

    # ask user for final confirmation
    print(f'Do you really want to remove container {cont_name}? {COLOR_RED}This may cause data loss!{COLOR_RESET}')
    if not ask_yes(False):
        print('Not removing container.')
        return

    # transfer volume ownership
    if len(transfer_paths) > 0:
        if not cont_running:
            _, code = shell(f'systemctl --user start "{cont_name}.service"')
            if code != 0:
                print('ERROR: Starting container failed. See {LOG_FILE} for details. Not removing container.')
                return;
        for path in transfer_paths:
            _, code = shell(f'podman exec -it "{cont_name}" bash -c "chown -R root:root \\"{path}\\""')
            if code != 0:
                print(f'ERROR: Ownership of {path} in container could not be transfered! See {LOG_FILE} for details. Not removing container.')
                return

    # remove systemd service
    shell(f'systemctl --user stop "{cont_name}.service"')
    shell(f'systemctl --user disable "{cont_name}.service"')
    shell(f'rm ~/.config/systemd/user/"{cont_name}.service"')

    # remove Podman container
    _, code = shell(f'podman rm "{cont_name}"')
    if code != 0:
        print(f'ERROR: Removing container failed! See {LOG_FILE} for details.')
        return

    # remove shell script
    path = f'{BASE_PATH}/{cont_name}.sh'
    shell(f'rm {path}')

    # success
    print(f'Container {cont_name} has been successfully removed.')


def main():

    global logger

    # set up logging to log file
    path = f'{BASE_PATH}/{LOG_FILE}'
    try:
        handler = logging.FileHandler(path, mode='w')
        handler.setFormatter(logging.Formatter(LOG_FORMAT))
        logger.addHandler(handler)
    except Exception as e:
        print(f'ERROR: Creating log file failed ({e}). Aborting...')
    logger.setLevel(logging.INFO)
    logger.info('Logging initialized.')

    # intialize argument parser
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(
        title='subcommands',
        description='build, list ("ananke SUBCOMMAND -h" for details)'
    )

    # subparser for build command
    parser_build = subparsers.add_parser(
        'build',
        help='build an image'
    )
    parser_build.set_defaults(func=subcmd_build)

    # subparser for create command
    parser_create = subparsers.add_parser(
        'create',
        help='create and start a container'
    )
    parser_create.set_defaults(func=subcmd_create)

    # subparser for list command
    parser_list = subparsers.add_parser(
        'list',
        help='list images and containers'
    )
    parser_list.set_defaults(func=subcmd_list)

    # subparser for remove command
    parser_remove = subparsers.add_parser(
        'remove',
        help='stop and remove a container'
    )
    parser_remove.set_defaults(func=subcmd_remove)

    # execute command
    args = parser.parse_args()
    if 'func' in args:
        args.func(args)
    else:
        parser.print_usage()


if __name__ == '__main__':
    main()
