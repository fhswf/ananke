import grp
import json
import logging
import os
import time
from collections import Counter
from glob import glob
from string import capwords
from subprocess import run, CalledProcessError

import numpy as np
from flask import Blueprint, Response, current_app
from flask import request as flask_request

from exceptions import AutogeneratedFileError
from misc.utils import read_autogenerated_config
from models.lti_file_reader import LTIFileReader

assignments_bp = Blueprint('assignments', __name__)


@assignments_bp.route('/assignments', methods=['GET', 'POST'])
def assignments():
    config_loader = current_app.config['CONFIG_LOADER']

    autogenerated_file_path = config_loader.autogenerated_file_path
    date_time_format = config_loader.date_time_format

    if flask_request.method == 'GET':
        try:
            user_name = flask_request.args.get('user')
            logging.debug(f'User: {user_name}')
        except KeyError:
            logging.error('Request key is not in form!')
            return Response(response=json.dumps({'message': 'KeyError'}), status=500)

        logging.info(f'User {user_name} is generating list of assignments for copy.')

        # Read and parse JSON file containing LTI data of current user.
        lti_file_reader: LTIFileReader = LTIFileReader(user_name=user_name, file_path=f'runtime/lti_{user_name}.json')
        lti_file_reader.read_file()
        lti_file_reader.extract_values()

        if lti_file_reader.read_success and lti_file_reader.parse_success:
            course_id, course_title, grader_user = lti_file_reader.course_id, lti_file_reader.course_title, lti_file_reader.grader_user
        else:
            return lti_file_reader.error_response

        # Access list of 'owned' groups, this is necessary to copy assignments stored at '/home/FORMGRADER_USER' and verifying access rights.
        try:
            _, _, groups = read_autogenerated_config(autogenerated_file_path=autogenerated_file_path)
        except AutogeneratedFileError:
            return Response(response=json.dumps({'message': 'AutogeneratedFileError'}), status=500)

        # TODO This is an optional feature where the problems of the course one is running in are NOT appended. This has to be evaluated, if it should stay or leave the code.
        #  Dependent on the decision the following code has to refactored.
        owned_groups = [group.lstrip('formgrade-') for group in groups if user_name in groups.get(group) and group.lstrip('formgrade-') != grader_user]
        base_paths = [item.path.removesuffix('/') for item in os.scandir('/home') if item.is_dir() and grp.getgrgid(os.stat(item.path).st_gid)[0] in owned_groups]
        logging.debug(f'Owned groups: {owned_groups}')
        logging.debug(f'Base paths: {base_paths}')

        # Get all paths of assignments for courses that are present and accessible. Due to possible sorting issues the list will be composed of to sub-lists which contain the paths
        # for assignments of active courses and paths for assignments of backed up courses respectively.
        active_assignment_paths = []
        for base_path in base_paths:
            active_assignment_paths.extend([
                assignment.removesuffix('/') for assignment in glob(pathname=f'{base_path}/course_data/source/*/') if glob(pathname=f'{assignment}**/*.ipynb', recursive=True)
            ])

        backed_up_assignment_paths = []
        backed_up_assignment_paths.extend([
            assignment.removesuffix('/') for assignment in glob(pathname=f'/var/lib/private/{user_name}/*/source/*/') if glob(pathname=f'{assignment}**/*.ipynb', recursive=True)
        ])

        # Check if the lists of assignment paths are empty. If that is the case return a message and status code indication just that.
        if not active_assignment_paths and not backed_up_assignment_paths:
            logging.error('No assignments found that can be copied.')
            return Response(response=json.dumps({'message': 'NoContentFound'}), status=500)

        # Sort the lists and generate combined list.
        active_assignment_paths = sorted(active_assignment_paths)
        logging.debug(f'Sorted active assignment paths: {active_assignment_paths}')
        backed_up_assignment_paths = sorted(backed_up_assignment_paths)
        logging.debug(f'Sorted backed up assignment paths: {backed_up_assignment_paths}')
        assignment_paths = active_assignment_paths + backed_up_assignment_paths
        logging.debug(f'Resulting complete course paths: {assignment_paths}')

        # Generate names to display in the dropdown menu of the kore extension. This is done separately for both lists, which is necessary due to sorting problematic induced by the
        # appending of a string representing the origin of the assignment to be copied (name of the active assignment with course id or backup with course name for backed up ones)
        # in interaction with the np.unique method which returns a sorted list again, which may not be in original order.
        active_assignment_names = []
        for active_assignment_path in active_assignment_paths:
            active_assignment_name = os.path.basename(active_assignment_path)

            split_string = active_assignment_path.split('/')
            info_file_path = f'/home/{split_string[2]}/info.json'

            try:
                with open(file=info_file_path) as info_file:
                    info = json.load(info_file)
            except FileNotFoundError:
                logging.error('Info file not found!')
                return Response(response=json.dumps({'message': 'FileNotFoundError'}), status=500)
            except PermissionError:
                logging.debug('Info file not readable!')
                run(['chmod', '600', info_file_path], check=True)
                with open(file=info_file_path, mode='r') as info_file:
                    info = json.load(info_file)
            except CalledProcessError:
                logging.error('Command cannot be executed!')
                return Response(response=json.dumps({'message': 'CalledProcessError'}), status=500)
            except OSError:
                logging.error('Info file can not be opened!')
                return Response(response=json.dumps({'message': 'OSError'}), status=500)

            course_id, course_title = info['id'], info['title']
            origin = course_title.removesuffix(f' ({course_id})')
            active_assignment_names.append(f'{active_assignment_name} ({origin})')

        logging.debug(f'Active assignment names: {active_assignment_names}')

        backed_up_course_names = []
        for backed_up_assignment_path in backed_up_assignment_paths:
            backed_up_assignment_name = os.path.basename(backed_up_assignment_path)

            split_string = backed_up_assignment_path.split('/')
            origin = f'Backup, {split_string[5]}'
            backed_up_course_names.append(f'{backed_up_assignment_name} ({origin})')

        logging.debug(f'Backed up assignment names: {backed_up_course_names}')

        # Check if strings in lists are unique. This is done with the np.unique function, which returns a tuple consisting of arrays for sorted unique elements and counts of those
        # elements. If not rename non-unique values by appending a string in form of f' ({i})', where i is an integer representing the count of the occurrence. This is necessary
        # for the proper accessing of the path of the assignment to be copied in 'index.ts' of the kore-extension.
        unique_assignment_names = []
        for assignment_names in [active_assignment_names, backed_up_course_names]:
            unique_array, unique_count = np.unique(assignment_names, return_counts=True)

            if not np.all(unique_count == 1):
                counts = dict(Counter(assignment_names))
                assignment_names = [key if i == 0 else key + f' ({i})' for key in unique_array for i in range(counts[key])]

            assignment_names = [capwords(name.replace('_', ' ')) for name in assignment_names]
            unique_assignment_names.extend(assignment_names)

        logging.debug(f'Unique assignment names: {unique_assignment_names}')

        assignment_list = {
            'message': 'List of assignments successfully retrieved.',
            'names': unique_assignment_names,
            'paths': assignment_paths
        }
        logging.info(f'Generated assignment list: {assignment_list}')

        return Response(response=json.dumps(assignment_list), status=200)

    if flask_request.method == 'POST':
        try:
            user_name, path = flask_request.json['user'], flask_request.json['path'].removesuffix('/')
            logging.debug(f'User: {user_name}')
            logging.debug(f'Path of assignment to be copied: {path}')
        except KeyError:
            logging.error('Request key is not in form!')
            return Response(response=json.dumps({'message': 'KeyError'}), status=500)

        logging.info(f'User {user_name} is copying assignment from {path}.')

        # Read and parse JSON file containing LTI data of current user.
        lti_file_reader: LTIFileReader = LTIFileReader(user_name=user_name, file_path=f'runtime/lti_{user_name}.json')
        lti_file_reader.read_file()
        lti_file_reader.extract_values()

        if lti_file_reader.read_success and lti_file_reader.parse_success:
            course_id, course_title, grader_user = lti_file_reader.course_id, lti_file_reader.course_title, lti_file_reader.grader_user
        else:
            return lti_file_reader.error_response

        # Get name of assignment to be copied.
        assignment_name = path.split('/')[-1]
        actual_time = time.strftime(date_time_format)
        logging.debug(f'Assignment name: {assignment_name}')
        logging.debug(f'Actual time: {actual_time}')

        # Copy assignment and change ownership.
        dst = f'/home/{grader_user}/course_data/source/{assignment_name} ({actual_time})/'

        # Check if the .../source/ folder for the grader user is present otherwise create it.
        source_folder = f'/home/{grader_user}/course_data/source/'

        if not os.path.isdir(source_folder):
            try:
                logging.debug(f'Executing: mkdir -p {source_folder}')
                run(['mkdir', '-p', source_folder], check=True)
            except CalledProcessError:
                logging.error('Command cannot be executed!')
                return Response(response=json.dumps({'message': 'CalledProcessError'}), status=500)

        try:
            logging.debug(f'Executing: cp -r {path}/ {dst}')
            run(['cp', '-r', f'{path}/', dst], check=True)
            logging.debug(f'Executing: chown -R {grader_user}:{grader_user} {dst}')
            run(['chown', '-R', f'{grader_user}:{grader_user}', dst], check=True)
        except CalledProcessError:
            logging.error('Command cannot be executed!')
            return Response(response=json.dumps({'message': 'CalledProcessError'}), status=500)

        return Response(response=json.dumps({'message': 'Selected assignment copied successfully! \n'
                                                        'Please refresh the webpage (Formgrader) to see the imported assignment.'}), status=200)
