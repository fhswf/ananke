import json
import logging
import time
from pathlib import Path
from subprocess import run, CalledProcessError

from flask import Response, Blueprint, current_app
from flask import request as flask_request
from nbgrader.api import Gradebook

from exceptions import AutogeneratedFileError
from misc.utils import read_autogenerated_config, write_autogenerated_config, get_course_list, load_info
from models.subset import Subset

courses_bp = Blueprint('courses', __name__)


# Defining subroute(s) for courses filtering. Available subroutes are:
# - active: Listing all active/running courses. Currently used for course backup, reset and deletion.
@courses_bp.route('/courses/active', methods=['GET'])
def active_courses():
    config_loader = current_app.config['CONFIG_LOADER']
    autogenerated_file_path = config_loader.autogenerated_file_path

    if flask_request.method == 'GET':
        try:
            return get_course_list(autogenerated_file_path=autogenerated_file_path, subset=Subset.ACTIVE)
        except ValueError:
            return Response(response=json.dumps({'message': 'ValueError'}), status=500)


@courses_bp.route('/courses', methods=['GET', 'POST', 'PUT', 'PATCH', 'DELETE'])
def courses():
    config_loader = current_app.config['CONFIG_LOADER']

    autogenerated_file_path = config_loader.autogenerated_file_path
    date_time_format = config_loader.date_time_format

    kore_token = current_app.config['KORE_TOKEN']

    # Retrieve full course list (active and backed up ones).
    # Note: Naming schema of paths is `/home/GRADER_USER/course_data/` for active courses and `/var/lib/private/USER/COURSE_NAME_YYMMDD_HHMMSS/source/` for backed up ones.
    if flask_request.method == 'GET':
        try:
            return get_course_list(autogenerated_file_path=autogenerated_file_path)
        except ValueError:
            return Response(response=json.dumps({'message': 'ValueError'}), status=500)

    # Copy a course.
    if flask_request.method == 'POST':
        try:
            src = flask_request.json['fromPath'].removesuffix('/')
            dst = flask_request.json['toPath'].removesuffix('/')
            dst = f'{dst}/source/'
        except KeyError:
            logging.error('Request key is not in form!')
            return Response(response=json.dumps({'message': 'KeyError'}), status=500)

        info = load_info(f'{src}/info.json')
        grader_user = info['grader_user']

        assignments = [d for d in Path(f'{src}/source/').iterdir() if d.is_dir() and not d.name.startswith('.')]
        for assignment in assignments:
            try:
                tmp = f'{assignment}_{time.strftime(date_time_format)}'
                run(['cp', '-r', assignment, tmp], check=True)
                run(['mkdir', '-p', dst], check=True)
                if Path(tmp).parent != Path(dst):
                    run(['mv', tmp, dst], check=True)
                run(['chown', '-R', f'{grader_user}:{grader_user}', dst], check=True)
            except CalledProcessError:
                logging.error('Command cannot be executed!')
                return Response(response=json.dumps({'message': 'CalledProcessError'}), status=500)

        return Response(response=json.dumps({'message': 'Selected course copied successfully! \n'
                                                        'Please refresh the webpage (Formgrader) to see the imported course.'}), status=200)

    # Backup a course.
    if flask_request.method == 'PUT':
        try:
            user_name = flask_request.json['user']
            src = flask_request.json['path'].removesuffix('/')
            name = flask_request.json['name']
        except KeyError:
            logging.error('Request key is not in form!')
            return Response(response=json.dumps({'message': 'KeyError'}), status=500)

        logging.info(f'User {user_name} is backing up course ({src}).')

        actual_date_time = time.strftime(date_time_format)
        dst = f'/var/lib/private/{user_name}/{name}_{actual_date_time}/'

        try:
            run(['cp', '-r', src, dst], check=True)
            run(['chown', '-R', f'{user_name}:{user_name}', dst], check=True)
        except CalledProcessError:
            logging.error('Command cannot be executed!')
            return Response(response=json.dumps({'message': 'CalledProcessError'}), status=500)

        return Response(response=json.dumps({'message': 'Selected course backed up successfully!'}), status=200)

    # Reset a course.
    if flask_request.method == 'PATCH':
        try:
            user_name = flask_request.json['user']
            path = flask_request.json['path'].removesuffix('/')
            logging.debug(f'User: {user_name}')
        except KeyError:
            logging.error('Request key is not in form!')
            return Response(response=json.dumps({'message': 'KeyError'}), status=500)

        # Read `info.json` file.
        try:
            info = load_info(f'{path}/info.json')
            course_id = info['id']
            base_url = info['target_link_uri']
        except KeyError:
            logging.error('Request key is not in info file!')
            return Response(response=json.dumps({'message': 'KeyError'}), status=500)

        logging.info(f'User {user_name} is resetting course ({path}).')

        # Remove students from gradebook.
        try:
            with Gradebook(f'sqlite:///{path}/gradebook.db') as gb:
                usernames = [student.id for student in gb.students]
                for username in usernames:
                    gb.remove_student(username)
        except FileNotFoundError:
            logging.error('Database not found!')
            return Response(response=json.dumps({'message': 'FileNotFoundError'}), status=500)
        except PermissionError:
            logging.error('Database can not be altered!')
            return Response(response=json.dumps({'message': 'PermissionError'}), status=500)
        except KeyError:
            logging.error('Invalid key for database supplied!')
            return Response(response=json.dumps({'message': 'KeyError'}), status=500)

        # Remove students from courses nbgrader group.
        logging.debug(f'Removing all students from nbgrader group of course {course_id}.')
        try:
            run(['systemd-run', 'curl',
                 '-H', 'Content-Type: application/json',
                 '-H', 'Accept: application/json',
                 '-H', f'Authorization: token {kore_token}',
                 '-X', 'DELETE',
                 '-d', '{"users":' + json.dumps(usernames) + '}',
                 f'http://127.0.0.1:8081/{base_url}hub/api/groups/nbgrader-{course_id}/users'], check=True)
        except CalledProcessError:
            logging.error('Command cannot be executed!')
            return Response(response=json.dumps({'message': 'CalledProcessError'}), status=500)

        # Clean up the nbgrader exchange directory.
        try:
            run(['rm', '-rf', f'/opt/nbgrader_exchange/{course_id}/'], check=True)
        except CalledProcessError:
            logging.error('Command cannot be executed!')
            return Response(response=json.dumps({'message': 'CalledProcessError'}), status=500)

        # Clean up course directory.
        try:
            run(['rm', f'{path}/gradebook.db'], check=True)
            for directory in ['autograded', 'feedback', 'release', 'submitted']:
                run(['rm', '-rf', f'{path}/{directory}/'], check=True)
        except CalledProcessError:
            logging.error('Command cannot be executed!')
            return Response(response=json.dumps({'message': 'CalledProcessError'}), status=500)

        return Response(response=json.dumps({'message': 'Selected course reset successfully!'}), status=200)

    # Delete a course.
    if flask_request.method == 'DELETE':
        try:
            user_name = flask_request.json['user']
            path = flask_request.json['path'].removesuffix('/')
        except KeyError:
            logging.error('Request key is not in form!')
            return Response(response=json.dumps({'message': 'KeyError'}), status=500)

        logging.info(f'User {user_name} is deleting course ({path}).')

        # Read `info.json` file.
        try:
            info = load_info(f'{path}/info.json')
            course_id = info['id']
            grader_user = info['grader_user']
        except KeyError:
            logging.error('Request key is not in info file!')
            return Response(response=json.dumps({'message': 'KeyError'}), status=500)

        # Get user's courses and corresponding information.
        try:
            services, roles, groups = read_autogenerated_config(autogenerated_file_path=autogenerated_file_path)
        except AutogeneratedFileError:
            return Response(response=json.dumps({'message': 'AutogeneratedFileError'}), status=500)

        # Access group and delete it from groups list.
        group = groups.get(f'formgrade-{course_id}')
        if not group:
            logging.error('Group not found in autogenerated configuration file!')
            return Response(response=json.dumps({'message': 'GroupNotFoundError'}), status=500)

        del groups[f'formgrade-{course_id}']
        logging.debug(f'Removed group for course {course_id}!')

        # Delete roles from roles lists.
        for role in roles:
            if role.get('name') == f'formgrader-{course_id}-role':
                del roles[roles.index(role)]
                logging.debug(f'Removed role for course {course_id}!')
            if role.get('name') == 'formgrader-service-role':
                del role['services'][role['services'].index(course_id)]

        # Delete services from services list.
        for service in services:
            if service['name'] == course_id:
                del services[services.index(service)]
                logging.debug(f'Removed service {course_id}!')
                break

        # Write resulting configuration file.
        try:
            write_autogenerated_config(autogenerated_file_path=autogenerated_file_path, services=services, roles=roles, groups=groups)
        except AutogeneratedFileError:
            return Response(response=json.dumps({'message': 'AutogeneratedFileError'}), status=500)

        # Delete nbgrader exchange directory for course.
        try:
            logging.debug(f'Removing nbgrader exchange for course {course_id}!')
            run(['rm', '-rf', f'/opt/nbgrader_exchange/{course_id}/'], check=True)
        except CalledProcessError:
            logging.error('Command cannot be executed!')
            return Response(response=json.dumps({'message': 'CalledProcessError'}), status=500)

        # Delete grader user for course.
        try:
            logging.debug(f'Removing grader user for course {course_id}!')
            run(['userdel', f'{grader_user}'], check=True)
            run(['rm', '-rf', f'/home/{grader_user}/'], check=True)
        except CalledProcessError:
            logging.error('Command cannot be executed!')
            return Response(response=json.dumps({'message': 'CalledProcessError'}), status=500)

        # Generate new nbgrader configuration code and write it to file.
        with open(file='/opt/conda/envs/jhub/etc/jupyter/nbgrader_config.py') as nb_grader_config:
            content = nb_grader_config.read()
        start = content.find('c.NbGrader.course_titles')
        end = content.find('}', start)
        pre = content[:start]
        code = content[start:end + 1]
        post = content[end + 1:]
        code = code.replace('c.NbGrader.course_titles = ', 'mapping.update(')
        code = code.replace('}', '})')
        mapping = {}
        exec(code + '\n')

        if course_id in mapping.keys():
            del mapping[course_id]

        with open(file='/opt/conda/envs/jhub/etc/jupyter/nbgrader_config.py', mode='w') as nb_grader_config:
            nb_grader_config.write(pre)
            nb_grader_config.write(f'c.NbGrader.course_titles = {str(mapping)}')
            nb_grader_config.write(post)

        # Restart JupyterHub to adopt the changes.
        logging.info('Restarting JupyterHub in 3 seconds...')
        run(['systemd-run', '--on-active=3', 'systemctl', 'restart', 'jupyterhub'])

        return Response(response=json.dumps({'message': 'Selected course deleted successfully! JupyterHub will restart soon!'}), status=200)
