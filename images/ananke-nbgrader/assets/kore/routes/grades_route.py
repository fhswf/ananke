import datetime
import json
import logging
import os
import time
from json import JSONDecodeError
from subprocess import run, CalledProcessError

import jwt
import requests
from flask import Blueprint, Response, current_app
from flask import request as flask_request
from nbgrader.api import Gradebook
from requests.exceptions import ConnectionError, HTTPError, RequestException
from urllib3.exceptions import LocationParseError

from exceptions import AutogeneratedFileError
from misc.utils import get_hub_base_url, read_autogenerated_config
from models.lti_file_reader import LTIFileReader

grades_bp = Blueprint('grades', __name__)


@grades_bp.route('/grades', methods=['POST'])
def grades():
    config_loader = current_app.config['CONFIG_LOADER']

    autogenerated_file_path = config_loader.autogenerated_file_path
    lti_config = config_loader.lti_config

    kore_token = current_app.config['KORE_TOKEN']

    if flask_request.method == 'POST':
        user_name = flask_request.json['user']
        logging.debug(f'User {user_name} indents to send grades to LMS.')

        # Read and parse JSON file containing LTI data of current user.
        lti_file_reader: LTIFileReader = LTIFileReader(user_name=user_name, file_path=f'runtime/lti_{user_name}.json')
        lti_file_reader.read_file()
        lti_file_reader.extract_values()

        if lti_file_reader.read_success and lti_file_reader.parse_success:
            lti_state = lti_file_reader.lti_state
            course_id, course_title, grader_user = lti_file_reader.course_id, lti_file_reader.course_title, lti_file_reader.grader_user
        else:
            return lti_file_reader.error_response

        # Get admin state.
        base_url = get_hub_base_url(lti_state)
        headers = {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            'Authorization': f'token {kore_token}',
        }

        try:
            response = requests.get(url=f'http://127.0.0.1:8081/{base_url}hub/api/users/{user_name}', headers=headers)
            response.raise_for_status()

        except HTTPError:
            logging.error('Accessing user data ended in HTTPError!')
            return Response(response=json.dumps({'message': 'HTTPError'}), status=500)

        except LocationParseError:
            logging.error('URL input failed to parse!')
            return Response(response=json.dumps({'message': 'LocationParseError'}), status=500)

        try:
            user_data = response.json()
            admin = user_data['admin']
            logging.debug(f'{user_name} is admin: {admin}')

        except JSONDecodeError:
            logging.error('Decode of response failed!')
            return Response(response=json.dumps({'message': 'JSONDecodeError'}), status=500)

        # Get user's courses and corresponding instructors.
        try:
            services, roles, groups = read_autogenerated_config(autogenerated_file_path=autogenerated_file_path)

        except AutogeneratedFileError:
            return Response(response=json.dumps({'message': 'AutogeneratedFileError'}), status=500)

        # TODO check with Jens if this is necessary or may be deleted. It was originally used as information that will be rendered on the original site. This can not happen here,
        #  due to the refactoring of kore.py. If necessary or otherwise defined as useful, move this code part to /home/.
        # ---
        course_ids, instructors = [], {}
        for group in groups:
            if not group.startswith('formgrade-'):
                continue

            # Check that user is either present in the actual group or has the admin state.
            if user_name in groups[group] or admin:

                # Get course id of actual processed group and append to list.
                course_id = group[len('formgrade-'):]
                course_ids.append(course_id)

                # Generate course specific instructor list for current course.
                instructors[course_id] = []
                for user in groups[group]:

                    # Ignore grader users (username starting with 'formgrade-') to only proceed with real users (username starting with u).
                    if not user.startswith('u'):
                        continue

                    # Read lti state file for every fitting user.
                    try:
                        with open(file=f'runtime/lti_{user}.json') as user_lti_state:
                            user_lti_state = json.load(user_lti_state)
                        full_name = str(user_lti_state.get('given_name')) + ' ' + str(user_lti_state.get('family_name'))
                        instructors[course_id].append(f'{full_name} ({user})')
                    except:  # no LTI state available for instructor
                        instructors[course_id].append(user)
        # ---

        # Create token for requesting access token from LMS.
        try:
            auth_token_request_data = {
                'iss': lti_state['aud'],
                'aud': lti_config['issuer'],
                'sub': lti_state['aud'],
                'iat': int(time.time()) - 5,
                'exp': int(time.time()) + 60,
            }

        except KeyError:
            logging.error('At least one key not found in LTI configuration or LTI state file!')
            return Response(response=json.dumps({'message': 'KeyError'}), status=500)

        # Read the private key of Kore.
        private_key_path = 'keys/lti_key'
        try:
            with open(file=private_key_path, mode='r') as private_key:
                private_key = private_key.read()

        except FileNotFoundError:
            logging.error('Private key not found!')
            return Response(response=json.dumps({'message': 'FileNotFoundError'}), status=500)

        except PermissionError:
            logging.debug('Private key not readable!')

            try:
                logging.debug('Trying to change permission of Kore private key file!')
                logging.debug(f'Executing chmod 600 {private_key_path}')
                run(['chmod', '600', private_key_path], check=True)

                with open(file=private_key_path, mode='r') as private_key:
                    private_key = private_key.read()

            except CalledProcessError:
                logging.error('Command cannot be executed!')
                return Response(response=json.dumps({'message': 'CalledProcessError'}), status=500)

        except OSError:
            logging.error('Private key can not be opened!')
            return Response(response=json.dumps({'message': 'OSError'}), status=500)

        # Read the public key of Kore.
        public_key_path = 'keys/lti_key.json'
        try:
            with open(file=public_key_path, mode='r') as public_key:
                jwk = json.load(public_key)

        except FileNotFoundError:
            logging.error('LTI key not found!')
            return Response(response=json.dumps({'message': 'FileNotFoundError'}), status=500)

        except PermissionError:
            logging.debug('Public key not readable!')

            try:
                logging.debug('Trying to change permission of Kore public key file!')
                logging.debug(f'Executing chmod 600 {public_key_path}')
                run(['chmod', '600', public_key_path], check=True)

                with open(file=public_key_path, mode='r') as public_key:
                    jwk = json.load(public_key)

            except CalledProcessError:
                logging.error('Command cannot be executed!')
                return Response(response=json.dumps({'message': 'CalledProcessError'}), status=500)

        except OSError:
            logging.error('LTI key can not be opened!')
            return Response(response=json.dumps({'message': 'OSError'}), status=500)
        except JSONDecodeError:
            logging.error('Decode of LTI key failed!')
            return Response(response=json.dumps({'message': 'JSONDecodeError'}), status=500)

        token = jwt.encode(auth_token_request_data, private_key, algorithm='RS256', headers={'kid': jwk['kid']})

        # Retrieve access token from LMS.
        params = {
            'grant_type': 'client_credentials',
            'client_assertion_type': 'urn:ietf:params:oauth:client-assertion-type:jwt-bearer',
            'client_assertion': token,
            'scope': 'https://purl.imsglobal.org/spec/lti-ags/scope/score https://purl.imsglobal.org/spec/lti-ags/scope/lineitem'
        }

        try:
            response = requests.post(lti_config['access_token_url'], data=params)
            response.raise_for_status()
        except KeyError:
            logging.error('Key (access_token_url) not found in the LTI configuration!')
            return Response(response=json.dumps({'message': 'KeyError'}), status=500)
        except HTTPError:
            logging.error('Posting request for accessing token from LMS ended in HTTPError!')
            return Response(response=json.dumps({'message': 'HTTPError'}), status=500)
        except LocationParseError:
            logging.error('URL input failed to parse!')
            return Response(response=json.dumps({'message': 'LocationParseError'}), status=500)

        try:
            access_token = response.json()['access_token']
        except JSONDecodeError:
            logging.error('Decode of response failed!')
            return Response(response=json.dumps({'message': 'JSONDecodeError'}), status=500)

        # Get score URL from line items.
        try:
            url, args = lti_state['https://purl.imsglobal.org/spec/lti-ags/claim/endpoint']['lineitem'].split('?')
            score_url = url + '/scores?' + args
        except KeyError:
            logging.error('Key regarding lineitem not found in LTI state file!')
            return Response(response=json.dumps({'message': 'KeyError'}), status=500)

        # Get users and scores from gradebook.
        student_ids = []
        scores = []
        max_scores = []

        # Due to the fact that the gradebook.db would be created while trying to access it with the Gradebook() code line we have to check here if it exists
        if not os.path.isfile(f'/home/{grader_user}/course_data/gradebook.db'):
            logging.error('Gradebook does not exist!')
            return Response(response=json.dumps({'message': 'GradebookNotExistentError'}), status=500)

        # TODO it may be necessary to check for read and write permission, it appears to work while noone had neither of those permissions
        with Gradebook(f'sqlite:////home/{grader_user}/course_data/gradebook.db') as gb:
            for student in gb.students:
                student_ids.append(student.lms_user_id)
                scores.append(student.score)
                max_scores.append(student.max_score)

        # Prepare user independent score data for sending.
        params = {
            'activityProgress': 'Completed',
            'gradingProgress': 'FullyGraded',
            'timestamp': datetime.datetime.now().astimezone().isoformat(),
            'userId': '',
            'comment': '',
        }
        headers = {
            'Authorization': 'Bearer ' + access_token,
            'Accept': 'application/json',
            'Content-Type': 'application/vnd.ims.lis.v1.score+json'
        }

        # Send scores to LMS.
        for student_id, score, max_score in zip(student_ids, scores, max_scores):
            params['userId'] = student_id
            params['scoreGiven'] = score
            params['scoreMaximum'] = max_score

            try:
                response = requests.post(score_url, json=params, headers=headers)
                response.raise_for_status()
                if response.status_code == 200:
                    logging.debug(f'Score(s) for student with ID {student_id} successfully send!')
            except HTTPError:
                logging.error(f'Posting grades to LMS for student with ID {student_id} ended in HTTPError!')
                return Response(response=json.dumps({'message': 'HTTPError'}), status=500)
            except ConnectionError:
                logging.error(f'Posting grades to LMS for student with ID {student_id} ended in ConnectionError!')
                return Response(response=json.dumps({'message': 'ConnectionError'}), status=500)
            except RequestException:
                logging.error(f'Posting grades to LMS for student with ID {student_id} ended in RequestException!')
                return Response(response=json.dumps({'message': 'RequestException'}), status=500)

        return Response(response=json.dumps({'message': 'Grades send successfully!'}), status=200)
