import grp
import json
import logging
import os
import time
from collections import Counter
from glob import glob
from string import capwords
from subprocess import run, CalledProcessError

import numpy as np
from flask import Blueprint, Response, current_app
from flask import request as flask_request

from exceptions import AutogeneratedFileError
from misc.utils import read_autogenerated_config
from models.lti_file_reader import LTIFileReader

problems_bp = Blueprint('problems', __name__)


@problems_bp.route('/problems', methods=['GET', 'POST'])
def problems():
    config_loader = current_app.config['CONFIG_LOADER']

    autogenerated_file_path = config_loader.autogenerated_file_path
    date_time_format = config_loader.date_time_format

    if flask_request.method == 'GET':
        try:
            user_name = flask_request.args.get('user')
            logging.debug(f'User: {user_name}')

        except KeyError:
            logging.error('Request key is not in form!')
            return Response(response=json.dumps({'message': 'KeyError'}), status=500)

        logging.info(f'User {user_name} is generating list of problems for copy.')

        # Read and parse JSON file containing LTI data of current user.
        lti_file_reader: LTIFileReader = LTIFileReader(user_name=user_name, file_path=f'runtime/lti_{user_name}.json')
        lti_file_reader.read_file()
        lti_file_reader.extract_values()

        if lti_file_reader.read_success and lti_file_reader.parse_success:
            course_id, course_title, grader_user = lti_file_reader.course_id, lti_file_reader.course_title, lti_file_reader.grader_user
        else:
            return lti_file_reader.error_response

        # Access list of 'owned' groups, this is necessary to copy assignments stored at '/home/FORMGRADER_USER' and verifying access rights.
        try:
            _, _, groups = read_autogenerated_config(autogenerated_file_path=autogenerated_file_path)

        except AutogeneratedFileError:
            return Response(response=json.dumps({'message': 'AutogeneratedFileError'}), status=500)

        # TODO This is an optional feature where the problems of the course one is running in are NOT appended. This has to be evaluated, if it should stay or leave the code.
        #  Dependent on the decision the following code has to refactored.
        owned_groups = [group.lstrip('formgrade-') for group in groups if user_name in groups.get(group) and group.lstrip('formgrade-') != grader_user]
        base_paths = [item.path.removesuffix('/') for item in os.scandir('/home') if item.is_dir() and grp.getgrgid(os.stat(item.path).st_gid)[0] in owned_groups]
        logging.debug(f'Owned groups: {owned_groups}')
        logging.debug(f'Base paths: {base_paths}')

        # Get all paths of problems for courses that are present and accessible. Due to possible sorting issues the list will be composed of to sub-lists which contain the paths
        # for problems of active courses and paths for problems of backed up courses respectively.
        active_problem_paths = []
        for base_path in base_paths:
            active_problem_paths.extend(glob(pathname=f'{base_path}/course_data/source/**/*.ipynb', recursive=True))

        backed_up_problem_paths = []
        backed_up_problem_paths.extend(glob(pathname=f'/var/lib/private/{user_name}/*/source/**/*.ipynb'))

        # Check if the lists of problem paths are empty. If that is the case return a message and status code indication just that.
        if not active_problem_paths and not backed_up_problem_paths:
            logging.error('No problems found that can be copied.')
            return Response(response=json.dumps({'message': 'NoContentFound'}), status=500)

        # Sort the lists and generate combined list.
        active_problem_paths = sorted(active_problem_paths)
        logging.debug(f'Sorted active assignment paths: {active_problem_paths}')
        backed_up_problem_paths = sorted(backed_up_problem_paths)
        logging.debug(f'Sorted backed up assignment paths: {backed_up_problem_paths}')
        problem_paths = active_problem_paths + backed_up_problem_paths
        logging.debug(f'Resulting complete course paths: {problem_paths}')

        # Generate names to display in the dropdown menu of the kore extension. This is done separately for both lists, which is necessary due to sorting problematic induced by the
        # appending of a string representing the origin of the problem to be copied (name of the active problem with course id or backup with assignment name for backed up ones) in
        # interaction with the np.unique method which returns a sorted list again, which may not be in original order.
        active_problem_names = []
        for active_problem_path in active_problem_paths:
            active_problem_name = os.path.basename(active_problem_path).removesuffix(".ipynb")

            split_string = active_problem_path.split('/')
            info_file_path = f'/home/{split_string[2]}/info.json'

            try:
                with open(file=info_file_path) as info_file:
                    info = json.load(info_file)

            except FileNotFoundError:
                logging.error('Info file not found!')
                return Response(response=json.dumps({'message': 'FileNotFoundError'}), status=500)

            except PermissionError:
                logging.debug('Info file not readable!')

                try:
                    logging.debug('Trying to change permission of info file!')
                    logging.debug(f'Executing chmod 600 {info_file_path}')
                    run(['chmod', '600', info_file_path], check=True)

                    with open(file=info_file_path, mode='r') as info_file:
                        info = json.load(info_file)

                except CalledProcessError:
                    logging.error('Command cannot be executed!')
                    return Response(response=json.dumps({'message': 'CalledProcessError'}), status=500)

            except OSError:
                logging.error('Info file can not be opened!')
                return Response(response=json.dumps({'message': 'OSError'}), status=500)

            course_id, course_title = info['id'], info['title']
            origin = course_title.removesuffix(f' ({course_id})')
            assignment_name = os.path.basename(os.path.dirname(active_problem_path))
            active_problem_names.append(f'{active_problem_name} ({origin} - {assignment_name})')

        logging.debug(f'Active problem names: {active_problem_names}')

        backed_up_problem_names = []
        for backed_up_problem_path in backed_up_problem_paths:
            problem_name = os.path.basename(backed_up_problem_path).removesuffix(".ipynb")

            origin = 'Backup'
            assignment_name = os.path.basename(os.path.dirname(backed_up_problem_path))
            backed_up_problem_names.append(f'{problem_name} ({origin} - {assignment_name})')

        logging.debug(f'Backed up problem names: {backed_up_problem_names}')

        # Check if strings in lists are unique. This is done with the np.unique function, which returns a tuple consisting of arrays for sorted unique elements and counts of those
        # elements. If not rename non-unique values by appending a string in form of f' ({i})', where i is an integer representing the count of the occurrence. This is necessary
        # for the proper accessing of the path of the assignment to be copied in 'index.ts' of the kore-extension.
        unique_problem_names = []
        for problem_names in [active_problem_names, backed_up_problem_names]:
            unique_array, unique_count = np.unique(problem_names, return_counts=True)

            if not np.all(unique_count == 1):
                counts = dict(Counter(problem_names))
                problem_names = [key if i == 0 else key + f' ({i})' for key in unique_array for i in range(counts[key])]

            problem_names = [capwords(name.replace('_', ' ')) for name in problem_names]
            unique_problem_names.extend(problem_names)

        logging.debug(f'Unique problem names: {unique_problem_names}')

        problem_list = {
            'message': 'List of problems successfully retrieved.',
            'names': unique_problem_names,
            'paths': problem_paths
        }
        logging.info(f'Generated problem list: {problem_list}')

        return Response(response=json.dumps(problem_list), status=200)

    if flask_request.method == 'POST':
        try:
            user_name, path = flask_request.json['user'], flask_request.json['path'].removesuffix('/')
            logging.debug(f'User: {user_name}')
            logging.debug(f'Path of problem to be copied: {path}')
        except KeyError:
            logging.error('Request key is not in form!')
            return Response(response=json.dumps({'message': 'KeyError'}), status=500)

        logging.info(f'User {user_name} is copying problem from {path}.')

        # Read and parse JSON file containing LTI data of current user.
        lti_file_reader: LTIFileReader = LTIFileReader(user_name=user_name, file_path=f'runtime/lti_{user_name}.json')
        lti_file_reader.read_file()
        lti_file_reader.extract_values()

        if lti_file_reader.read_success and lti_file_reader.parse_success:
            course_id, course_title, grader_user = lti_file_reader.course_id, lti_file_reader.course_title, lti_file_reader.grader_user
        else:
            return lti_file_reader.error_response

        # Get name of problem to be copied.
        problem_name = path.split('/')[-1].removesuffix('.ipynb')
        logging.debug(f'Problem name: {problem_name}')

        # Check if the folder for imported problems exists.
        if not os.path.isdir(f'/home/{grader_user}/course_data/source/imported_problems/'):
            try:
                logging.debug(f'Executing: mkdir -p /home/{grader_user}/course_data/source/imported_problems/')
                run(['mkdir', '-p', f'/home/{grader_user}/course_data/source/imported_problems/'], check=True)
                logging.debug(f'Executing: chown {grader_user}:{grader_user} /home/{grader_user}/course_data/source/imported_problems/')
                run(['chown', f'{grader_user}:{grader_user}', f'/home/{grader_user}/course_data/source/imported_problems/'], check=True)
            except CalledProcessError:
                logging.error('Command cannot be executed!')
                return Response(response=json.dumps({'message': 'CalledProcessError'}), status=500)

        # Copy problem with timestamp and change ownership.
        actual_time = time.strftime(date_time_format)
        dst = f'/home/{grader_user}/course_data/source/imported_problems/{problem_name} ({actual_time}).ipynb'

        try:
            logging.debug(f'Executing: cp {path} {dst}')
            run(['cp', f'{path}', dst], check=True)
            logging.debug(f'Executing: chown {grader_user}:{grader_user} {dst}')
            run(['chown', f'{grader_user}:{grader_user}', dst], check=True)
        except CalledProcessError:
            logging.error('Command cannot be executed!')
            return Response(response=json.dumps({'message': 'CalledProcessError'}), status=500)

        return Response(response=json.dumps({'message': 'Selected problem copied successfully! \n'
                                                        'Please refresh the webpage (Formgrader) to see the imported problem.'}), status=200)
