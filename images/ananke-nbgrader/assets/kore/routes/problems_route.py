import json
import logging
import os
import time
from subprocess import run, CalledProcessError

from flask import Blueprint, Response, current_app
from flask import request as flask_request

from misc.utils import get_problem_list
from models.lti_file_reader import LTIFileReader

problems_bp = Blueprint('problems', __name__)


@problems_bp.route('/problems', methods=['GET', 'POST'])
def problems():
    config_loader = current_app.config['CONFIG_LOADER']

    autogenerated_file_path = config_loader.autogenerated_file_path
    date_time_format = config_loader.date_time_format

    # Retrieve full problem list (active and backed up ones).
    if flask_request.method == 'GET':
        try:
            return get_problem_list(autogenerated_file_path=autogenerated_file_path)
        except ValueError:
            return Response(response=json.dumps({'message': 'ValueError'}), status=500)

            try:
                with open(file=info_file_path) as info_file:
                    info = json.load(info_file)
            except FileNotFoundError:
                logging.error('Info file not found!')
                return Response(response=json.dumps({'message': 'FileNotFoundError'}), status=500)
            except PermissionError:
                logging.debug('Info file not readable!')
                run(['chmod', '600', info_file_path], check=True)
                with open(file=info_file_path, mode='r') as info_file:
                    info = json.load(info_file)
            except CalledProcessError:
                logging.error('Command cannot be executed!')
                return Response(response=json.dumps({'message': 'CalledProcessError'}), status=500)
            except OSError:
                logging.error('Info file can not be opened!')
                return Response(response=json.dumps({'message': 'OSError'}), status=500)

            course_id, course_title = info['id'], info['title']
            origin = course_title.removesuffix(f' ({course_id})')
            assignment_name = os.path.basename(os.path.dirname(active_problem_path))
            active_problem_names.append(f'{active_problem_name} ({origin} - {assignment_name})')

        logging.debug(f'Active problem names: {active_problem_names}')

        backed_up_problem_names = []
        for backed_up_problem_path in backed_up_problem_paths:
            problem_name = os.path.basename(backed_up_problem_path).removesuffix(".ipynb")

            origin = 'Backup'
            assignment_name = os.path.basename(os.path.dirname(backed_up_problem_path))
            backed_up_problem_names.append(f'{problem_name} ({origin} - {assignment_name})')

        logging.debug(f'Backed up problem names: {backed_up_problem_names}')

        # Check if strings in lists are unique. This is done with the np.unique function, which returns a tuple consisting of arrays for sorted unique elements and counts of those
        # elements. If not rename non-unique values by appending a string in form of f' ({i})', where i is an integer representing the count of the occurrence. This is necessary
        # for the proper accessing of the path of the assignment to be copied in 'index.ts' of the kore-extension.
        unique_problem_names = []
        for problem_names in [active_problem_names, backed_up_problem_names]:
            unique_array, unique_count = np.unique(problem_names, return_counts=True)

            if not np.all(unique_count == 1):
                counts = dict(Counter(problem_names))
                problem_names = [key if i == 0 else key + f' ({i})' for key in unique_array for i in range(counts[key])]

            problem_names = [capwords(name.replace('_', ' ')) for name in problem_names]
            unique_problem_names.extend(problem_names)

        logging.debug(f'Unique problem names: {unique_problem_names}')

        problem_list = {
            'message': 'List of problems successfully retrieved.',
            'names': unique_problem_names,
            'paths': problem_paths
        }
        logging.info(f'Generated problem list: {problem_list}')

        return Response(response=json.dumps(problem_list), status=200)

    if flask_request.method == 'POST':
        try:
            user_name, path = flask_request.json['user'], flask_request.json['path'].removesuffix('/')
            logging.debug(f'User: {user_name}')
            logging.debug(f'Path of problem to be copied: {path}')
        except KeyError:
            logging.error('Request key is not in form!')
            return Response(response=json.dumps({'message': 'KeyError'}), status=500)

        logging.info(f'User {user_name} is copying problem from {path}.')

        # Read and parse JSON file containing LTI data of current user.
        lti_file_reader: LTIFileReader = LTIFileReader(user_name=user_name, file_path=f'runtime/lti_{user_name}.json')
        lti_file_reader.read_file()
        lti_file_reader.extract_values()

        if lti_file_reader.read_success and lti_file_reader.parse_success:
            course_id, course_title, grader_user = lti_file_reader.course_id, lti_file_reader.course_title, lti_file_reader.grader_user
        else:
            return lti_file_reader.error_response

        # Get name of problem to be copied.
        problem_name = path.split('/')[-1].removesuffix('.ipynb')
        logging.debug(f'Problem name: {problem_name}')

        # Check if the folder for imported problems exists.
        if not os.path.isdir(f'/home/{grader_user}/course_data/source/imported_problems/'):
            try:
                run(['mkdir', '-p', f'/home/{grader_user}/course_data/source/imported_problems/'], check=True)
                run(['chown', f'{grader_user}:{grader_user}', f'/home/{grader_user}/course_data/source/imported_problems/'], check=True)
            except CalledProcessError:
                logging.error('Command cannot be executed!')
                return Response(response=json.dumps({'message': 'CalledProcessError'}), status=500)

        # Copy problem with timestamp and change ownership.
        actual_time = time.strftime(date_time_format)
        dst = f'/home/{grader_user}/course_data/source/imported_problems/{problem_name} ({actual_time}).ipynb'

        try:
            run(['cp', f'{path}', dst], check=True)
            run(['chown', f'{grader_user}:{grader_user}', dst], check=True)
        except CalledProcessError:
            logging.error('Command cannot be executed!')
            return Response(response=json.dumps({'message': 'CalledProcessError'}), status=500)

        return Response(response=json.dumps({'message': 'Selected problem copied successfully! \n'
                                                        'Please refresh the webpage (Formgrader) to see the imported problem.'}), status=200)
